# Ptolemy <small>- Elixir Application Secret Management</small>

> This document is designed to facilitate and grow with design discussions and is not yet complete

Ptolemy is now at a current stage where our thinking goes beyond the simple accessing and updating of secrets stored in a Vault server. For the idea of Application Managed secrets to fully be an accepted practice in the Elixir community, an effective and elegant solution will need to be built. We hope Ptolemy can fill this void.

## Components

### Secret Life-cycle Management

> It is still TBD if this functionality belongs in Ptolemy but it will begin here.

Traditionally, all secrets in Elixir have been backed in, or set once and forgotten. This strategy works well with the nature of common secrets. With the introduction of tools like Vault, the availability of dynamic secrets and the additional security they provide will require a non-traditional approach to leverage correctly.

The solution we propose comes from the Erlang methodology of 'let it crash'. We propose that on a change of environment, we should 'make it crash'. When performed intelligently, processes that depend on an expired/changed secret could be made to crash, restart, then reinitialize with the updated secrets.

Application secrets (and even simple configuration because its so easy) would be defined in the application's typical config:

```elixir
config :ptolemy,
	env: [
		{:secret_one, {Ptolemy.Providers.Vault.KeyVal, "VAULT_SECRET_NAME"}},
		{:secret_two, {Ptolemy.Providers.SystemEnv, "SOME_SYSTEM_ENV"}},
		# ...
	]
```

Secrets can also be associated with processes that should restart when they have been changed:

```elixir
config :ptolemy,
	env: [
		{:secret_one, {Ptolemy.Providers.Vault.KeyVal, "VAULT_SECRET_NAME"}, restart_on_change: :my_db_pid},
		# ...
	]
```

To use the config, use Ptolemy's `start_link/2` implementation:

```elixir
defmodule MyApp.Supervisor do
	use Supervisor

	def start_link(init_arg) do
		Ptolemy.Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)
	end

	@impl true
  	def init(_init_arg) do
    	children = [
      		{Stack, [:hello]}
    	]

    	Ptolemy.Supervisor.init(children, strategy: :one_for_one)
  	end
end
```

The Ptolemy implementation of `Supervisor` would simply add an additional Ptolemy process to the start of the supervision tree. The resulting tree would look like something generated by:
```elixir
def init(_init_arg) do
    	children = [
 			Ptolemy.Monitor,   		
      		{MyApp.Process1, []},
      		# ...
    	]

    	Supervisor.init(children, strategy: :one_for_one)
  	end
```

And would yield a supervision tree similar to:

```
              +--------------------------+
              |                          |
              |  Application Supervisor  |
              |                          |
              +--+----------+-----------++
                 |          |           |
                 |          |           |
                 v          v           +-------v
+----------------+--+   +---+---+           +---+---+
|                   |   |       |           |       |
|  Ptolemy.Monitor  |   |   P1  |   ....    |   Pn  |
|                   |   |       |           |       |
+-------------------+   +-------+           +-------+

```

It would be this Monitor that will be responsible for populating the Application's env (to update the return values of `Application.get_env/2`). The call to `Ptolemy.Monitor.start_link/1` will perform the population according to the configs defined above. For each configuration provider defined in the config, a linked process could be started and managed by the monitor.

Configuration providers would adhere to the behavior defined by `Ptolemy.Provider.Spec`. This spec would enforce each provider to consist of a module that looks something like:
```elixir
defmodule Ptolemy.Providers.Vault.KeyValue do
	use Ptolemy.Provider

	@impl
	def init_monitor(monitor_pid, config) do
		# ....
	end

	@impl
	def handle_query(query) do
		# ....
	end
end
```

The behavior declaration would be wrapped in the typical macro style used by other popular frameworks, allowing the addition of powerful helper methods and compile time tricks.

The `handle_query/1` function would handle any queries made to the provider. The query can follow any format as it is provider specific, and usually specified as the argument provided in the config. The result of `handle_query/1` will be the value queried for. In the case of the value cannot be found, `nil` or an error should be returned.

The `init_monitor/2` function will be called to initialize the monitoring of the backend/api bindings the provider will communicate with to respond to queries. An element of note is the presence of the `monitor_pid` argument. The purpose of this argument is to provide a pid to send a message back to the monitor when the provider notices a change in it's backend and wishes to update the application. Upon sending the change event, the `Monitor` will smartly decide based on the configuration if and what process to restart. Possible decisions would include:

* Crashing the monitor. This would - provided the application supervisor is using the `:one_for_all` strategy - would restart the whole application and as a result, the `Monitor` process which will reload the `Application`'s environment
* Crashing and restarted a particular process with the correct calls to the supervisor
* Nothing. Code that periodically pulls from `Application.get_env/2` would automatically adapt with the change.

## Built-In Providers

> It is not clear if Ptolemy should come with all, a core few, or no Providers where they will need to be included as separate integration libraries, however the implementations above are designed to be loose enough to support all three strategies, and allow developers to create their own Providers with ease

### Vault

We think the highest value vault engines to support would include:

* GCP
* Key/Val
* Cubbyhole
* PKI
* TOTP
* Databases

Initial release would be focused on `Key/Val` support but bindings listed above will be on the road map.